The compilation is a process of converting the source code into object code. It is done with the help of the compiler. The compiler checks the source code for the syntactical or structural errors, and if the source code is error-free, then it generates the object code.

Java, being a platform-independent programming language, doesn’t work on the one-step compilation. Instead, it involves a two-step execution, first through an OS-independent compiler; and second, in a virtual machine (JVM) which is custom-built for every operating system.


### Principle 1: Compilation

First, the source ‘.java’ file is passed through the compiler, which then encodes the source code into a machine-independent encoding, known as Bytecode. The content of each class contained in the source file is stored in a separate ‘.class’ file.

### **Principle 2:** Execution

The class files generated by the compiler are independent of the machine or the OS, which allows them to be run on any system. To run, the main class file (the class that contains the method main) is passed to the JVM and then goes through three main stages before the final machine code is executed. These stages are:  
These states do include:

1.  ClassLoader
2.  Bytecode Verifier
3.  [Just-In-Time Compiler](https://www.geeksforgeeks.org/compilation-execution-java-program/)

**Stage 1:** [Class Loader](https://www.geeksforgeeks.org/classloader-in-java/)

The main class is loaded into the memory bypassing its ‘.class’ file to the JVM, through invoking the latter. All the other classes referenced in the program are loaded through the class loader.  
A class loader, itself an object, creates a flat namespace of class bodies that are referenced by a string name.

There are two types of class loaders

-   primordial
-   non-primordial

The primordial class loader is embedded into all the JVMs and is the default class loader. A non-primordial class loader is a user-defined class loader, which can be coded in order to customize the class-loading process. Non-primordial class loader, if defined, is preferred over the default one, to load classes.

**Stage 2:** [Bytecode Verifier](https://www.geeksforgeeks.org/verification-java-jvm/)

After the bytecode of a class is loaded by the class loader, it has to be inspected by the bytecode verifier, whose job is to check that the instructions don’t perform damaging actions. The following are some of the checks carried out: 

-   Variables are initialized before they are used.
-   Method calls match the types of object references.
-   Rules for accessing private data and methods are not violated.
-   Local variable accesses fall within the runtime stack.
-   The run-time stack does not overflow.
-   If any of the above checks fail, the verifier doesn’t allow the class to be loaded.

**Stage 3:** [Just-In-Time Compiler](https://www.geeksforgeeks.org/just-in-time-compiler/)

This is the final stage encountered by the java program, and its job is to convert the loaded bytecode into machine code.